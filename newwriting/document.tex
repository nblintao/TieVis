\documentclass{article}
\title{Part of the Paper}
\author{Tao LIN}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{amsmath}


\begin{document}

\maketitle

\section{Bipartite View}

In the bipartite view, we introduce a visualization of both the temporal and topological information about the selected edges.
The temporal information is encoded horizontally. We visualize a bipartite graph for each time step, and the visualization for the time steps is horizontally arranged according to the temporal sequence.

For each time step, we display the related edges regarding to their source and target vertices. Two parallel vertical axes are used to arrange the related vertices. The left axe encodes the source vertices of the edges, and the right one encodes the target vertices. Each edge is visually encoded as a link between the left axe and the right one. 

In order to minimize the visual clutter within the time short enough, we should optimize the way vertices are arranged on the axes.
Here are several ways considered.

//TODO: early considerations

In order to find a balance between visual quality and respond speed, we finally decide to do the optimization hierarchically. The related vertices are grouped, and the vertices in the same group are aligned together. Then, we optimize the alignment of the vertices in the groups and the alignment of these groups.

The grouping is according to the connectivity of the vertices in the selected time step. The vertices of the edges connected together are regarded as in the same group. By mentioning the selected time step here, it is important to point out that the alignments are identical for distinct time steps. If the alignments are distinct for the time steps, it would be difficult for the analyzer to find the pattern. If edges of all time steps are considered, the connected subsets may be too large to minimize the visual clutter quickly.

// TODO: inner-group alignment


\begin{algorithm}[h]
	\caption{Inner-group Alignment Algorithm}
	\label{alg::innergroup}
	\begin{algorithmic}[1]
		\Require
		$G = \{e_0, e_1, ..., e_{n-1}\}$: edges in the group $G$;
		\Ensure
		$G' = \{e_{k_0}, e_{k_1}, ..., e_{k_{n-1}}\}$: optimized alignment $G$;
		\If {$n < 2$ }
			\State $G' = G$
		\Else
				\State $minCross = $ maximum number
				\State $perms = $ all permutations of $G$
				\For {$perm$ in $perms$}
					\State $cross = 0$
					\For {$i=0; i<n-1; i=i+1$}
						\For {$j=i+1; j<n; j=j+1$}
							\If {$e_i.source \neq e_j.source$ and $e_i.target \neq e_j.target$}
								\State $ps = $ position of $e_i.source$ in $perm$ $>$ position of $e_j.source$ in $perm$
								\State $pt = $ position of $e_i.target$ in $perm$ $>$ position of $e_j.target$ in $perm$
								\If {$ps \neq pt$}
									\State $cross = cross+1 $
								\EndIf
							\EndIf
						\EndFor					
					\EndFor
					\If {$cross < minCross$}
						\If {$cross = 0$}
							\State break;
						\EndIf
						\State $G' = perm$
						\State $minCross = cross$
					\EndIf
				\EndFor
		\EndIf
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[h]
	\caption{Inter-group Alignment Algorithm}
	\label{alg::intergroup}
	\begin{algorithmic}[1]
		\Require
		$S = \{G_0, G_1, ..., G_{n-1}, H\}$: A set of edge groups $G_i$ and a group of other edges $H$;
		
		$E = {e_0, e_1, \dots, e_{w-1}}$: the set of all edges
		\Ensure
		$S' = \{e_{k_0}, e_{k_1}, ..., e_{k_{n-1}}, H\}$: optimized alignment $S$;
		\If {$n<2$}
			\State $S' = S$
		\Else
			\State $transGroup = []$
			\State $relatedGroups = \{\}$
			\For {$e$ in $E$}
				\State $ps = $ the group contains $e.source$
				\State $pt = $ the group contains $e.target$
				\If {$ps = pt$}
					\State continue
				\EndIf
				\If {$ps$ is not in $relatedGroups$}
					\State add $ps$ into $relatedGroups$
				\EndIf
				\If {$pt$ is not in $relatedGroups$}
					\State add $pt$ into $relatedGroups$
				\EndIf
				\State $transGroup[ps,pt] += $ number of times Edge $e$ exists
			\EndFor
			\State $frontPart = G - relatedGroups- \{H\}$
			\State $middlePart = relatedGroups- \{H\}$
			
			
\State $minCrossValue = $ maximum number
\State $perms = $ all permutations of $middlePart$
\For {$perm$ in $perms$}
	\State $crossValue = 0$
	\State $perm = frontPart + perm + {H}$
	\For {$i=0; i<n; i=i+1$}
		\For {$j=i+1; j<n+1; j=j+1$}
			\State $crossValue += transGroup[perm[i],perm[j]] \cdot (j-i)$
		\EndFor					
	\EndFor
	\If {$crossValue < minCrossValue$}
		\State $G' = perm$
		\State $minCrossValue = crossValue$
	\EndIf
\EndFor
			
		\EndIf
	\end{algorithmic}
\end{algorithm}



// TODO: inter-group alignment






\end{document}

