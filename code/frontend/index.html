<!DOCTYPE html>
<html>
<head>
    <title>Large Graphs Visualizer</title>
<script type="text/javascript" src="js/two.min.js"></script>
<script type="text/javascript" src="data/icoord.js"></script>
<script type="text/javascript" src="data/iedges.js"></script>
</script>
</head>
<body>

<script>
/* url */
(function(url) {
    
  var result = {},
      hashLoc = url.indexOf('#');

  url.substring(url.indexOf('?')).replace(
    /([^?=&]+)(=([^&]+))?/g,
    function($0, $1, $2, $3) {
      result[$1] = $3;
    }
  );

  result['boolean'] = function(name, defaultValue) {
    if (!result.hasOwnProperty(name))
      return defaultValue;
    return result[name] !== 'false';
  };

  result['float'] = function(name, defaultValue) {
    var r = parseFloat(result[name]);
    if (r != r) 
      return defaultValue;
    return r;
  };

  result['int'] = function(name, defaultValue) {
    var r = parseInt(result[name], 10);
    if (r != r) 
      return defaultValue;
    return r;
  };

  result['hash'] = hashLoc == -1 ? undefined : url.substring(hashLoc+1);

  result['setUrl'] = arguments.callee; 

  window['url'] = result;

})(location.href);


/* has */
(function() {
 
  var root = this;
  var previousHas = root.has || {};
 
  // Let's do a bunch of navigator detections shall we?
 
  var ua = root.navigator.userAgent;
 
  var has = {
 
    // Mobile Detection
 
    Android: !!ua.match(/Android/ig),
    Blackberry: !!ua.match(/BlackBerry/ig),
    iOS: !!ua.match(/iPhone|iPad|iPod/ig),
    OperaMini: !!ua.match(/Opera Mini/ig),
    Windows: !!ua.match(/IEMobile/ig),
    WebOS: !!ua.match(/webOS/ig),
 
    // Browser Detection
 
    Arora: !!ua.match(/Arora/ig),
    Chrome: !!ua.match(/Chrome/ig),
    Epiphany: !!ua.match(/Epiphany/ig),
    Firefox: !!ua.match(/Firefox/ig),
    InternetExplorer: !!ua.match(/MSIE/ig),
    Midori: !!ua.match(/Midori/ig),
    Opera: !!ua.match(/Opera/ig),
    Safari: !!ua.match(/Safari/ig),
 
    webgl: (function() { try { return !!window.WebGLRenderingContext && !!(document.createElement('canvas').getContext('webgl') || document.createElement('canvas').getContext('experimental-webgl')); } catch(e) { return false; } })(),
 
    noConflict: function() {
      return previousHas;
    }
 
  };
 
  has.mobile = has.Android || has.Blackberry || has.iOS || has.OperaMini || has.Windows || has.WebOS;
 
  root.has = has;
 
})();

// use webgl by default
var type = /(canvas|webgl|svg)/.test(url.type) ? url.type : 'webgl';

// if the browser does not support webgl
// use svg insteal
if (type === 'webgl' && !has.webgl) {
    alert('Yikes! This browser does not support WebGL.');
    type = 'svg';
}

var two = new Two({
  type: Two.Types[type],
  fullscreen: true
}).appendTo(document.body);

console.log(type);

// var circle = two.makeCircle(-70, 0, 50);
// var rect = two.makeRectangle(70, 0, 100, 100);
// circle.fill = '#FF8000';
// rect.fill = 'rgba(0, 200, 255, 0.75)';

// var group = two.makeGroup(circle, rect);
// group.translation.set(two.width / 2, two.height / 2);
// group.scale = 0;
// group.noStroke();
var start=new Date()
console.log("start timing");

// icoord = [[1,1],[2,2],[3,3],[4,4],[5,5]];
xcoord = icoord.map(function(d){return d[0]});

ycoord = icoord.map(function(d){return d[1]});
// console.log(xcoord,ycoord);
var maxx = Math.max.apply(null,xcoord),
    minx = Math.min.apply(null,xcoord),
    scax = two.width/(maxx - minx),
    maxy = Math.max.apply(null,ycoord),
    miny = Math.min.apply(null,ycoord),
    scay = two.height/(maxy - miny);

// console.log(two.width);

console.log(new Date() - start + ' ms(before makeCircle)');

function generate(amount) {
	var r = Math.random() * radius + radius / 2;
	return _.map(_.range(amount), function(i) {
	  var pct = i / amount;
	  var angle = pct * Math.PI * 2;
	  var x = r * Math.cos(angle);
	  var y = r * Math.sin(angle);
	  var anchor = new Two.Anchor(x, y);
	  anchor.origin = new Two.Vector().copy(anchor);
	  vertices++;
	  return anchor;
	});
}

Two.Resolution = 4;

var makeStraightCircle = function(ox, oy, r) {
    return makeStraightEllipse(ox, oy, r, r);
}

var makeStraightEllipse = function(ox, oy, width, height) {

      var amount = Two.Resolution;

      var points = _.map(_.range(amount), function(i) {
        var pct = i / amount;
        var theta = pct * Math.PI*2;
        var x = width * Math.cos(theta);
        var y = height * Math.sin(theta);
        return new Two.Anchor(x, y);
      }, this);

      var ellipse = new Two.Polygon(points, true, false);
      ellipse.translation.set(ox, oy);

      two.scene.add(ellipse);

      return ellipse;
}

var offset = 200;
var circleList = [];
for (var i = 0; i < 3000; i++) {
    var circle = two.makeCircle(-offset,-offset,5);
    circle.fill = '#FF8000';
    circleList.push(circle);
};
// icoord.map(function(d){
//     var circle = two.makeCircle(scax*(d[0]-minx),scay*(d[1]-miny),5);
//     // var circle = makeStraightCircle(scax*(d[0]-minx),scay*(d[1]-miny),5);
//     // dat.push(scax*(d[0]-minx));
//     circle.fill = '#FF8000';
//     // circleList.push(circle)
// });

console.log(new Date() - start + ' ms(after makeCircle)');


for (var i = icoord.length - 1; i >= 0; i--) {
    var d = icoord[i];
    circleList[i].translation.set(scax*(d[0]-minx),scay*(d[1]-miny));
};


console.log(new Date() - start + ' ms(after move)');

for (var i = iedges.length - 1; i >= 0; i--) {
    var d = iedges[i];
    var line = two.makeLine(
        scax*(icoord[d[0]][0]-minx),scay*(icoord[d[0]][1]-miny),
        scax*(icoord[d[1]][0]-minx),scay*(icoord[d[1]][1]-miny));
};

console.log(new Date() - start + ' ms(after lines)');



two.update();

console.log(new Date() - start + ' ms(after render)');

// // Bind a function to scale and rotate the group
// // to the animation loop.
// two.bind('update', function(frameCount) {
//   // This code is called everytime two.update() is called.
//   // Effectively 60 times per second.
//   if (group.scale > 0.9999) {
//     group.scale = group.rotation = 0;
//   }
//   var t = (1 - group.scale) * 0.125;
//   group.scale += t;
//   group.rotation += t * 4 * Math.PI;
// }).play();  // Finally, start the animation loop


</script>
</body>
</html>