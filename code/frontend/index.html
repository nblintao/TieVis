<!DOCTYPE html>
<html>
<head>
    <title>Large Graphs Visualizer</title>
<script type="text/javascript" src="js/two.min.js"></script>
<script type="text/javascript" src="data/icoord.js"></script>
<script type="text/javascript" src="data/iedges.js"></script>
</script>
</head>
<body>

<script>
/* url */
(function(url) {
    
  var result = {},
      hashLoc = url.indexOf('#');

  url.substring(url.indexOf('?')).replace(
    /([^?=&]+)(=([^&]+))?/g,
    function($0, $1, $2, $3) {
      result[$1] = $3;
    }
  );

  result['boolean'] = function(name, defaultValue) {
    if (!result.hasOwnProperty(name))
      return defaultValue;
    return result[name] !== 'false';
  };

  result['float'] = function(name, defaultValue) {
    var r = parseFloat(result[name]);
    if (r != r) 
      return defaultValue;
    return r;
  };

  result['int'] = function(name, defaultValue) {
    var r = parseInt(result[name], 10);
    if (r != r) 
      return defaultValue;
    return r;
  };

  result['hash'] = hashLoc == -1 ? undefined : url.substring(hashLoc+1);

  result['setUrl'] = arguments.callee; 

  window['url'] = result;

})(location.href);


/* has */
(function() {
 
  var root = this;
  var previousHas = root.has || {};
 
  // Let's do a bunch of navigator detections shall we?
 
  var ua = root.navigator.userAgent;
 
  var has = {
 
    // Mobile Detection
 
    Android: !!ua.match(/Android/ig),
    Blackberry: !!ua.match(/BlackBerry/ig),
    iOS: !!ua.match(/iPhone|iPad|iPod/ig),
    OperaMini: !!ua.match(/Opera Mini/ig),
    Windows: !!ua.match(/IEMobile/ig),
    WebOS: !!ua.match(/webOS/ig),
 
    // Browser Detection
 
    Arora: !!ua.match(/Arora/ig),
    Chrome: !!ua.match(/Chrome/ig),
    Epiphany: !!ua.match(/Epiphany/ig),
    Firefox: !!ua.match(/Firefox/ig),
    InternetExplorer: !!ua.match(/MSIE/ig),
    Midori: !!ua.match(/Midori/ig),
    Opera: !!ua.match(/Opera/ig),
    Safari: !!ua.match(/Safari/ig),
 
    webgl: (function() { try { return !!window.WebGLRenderingContext && !!(document.createElement('canvas').getContext('webgl') || document.createElement('canvas').getContext('experimental-webgl')); } catch(e) { return false; } })(),
 
    noConflict: function() {
      return previousHas;
    }
 
  };
 
  has.mobile = has.Android || has.Blackberry || has.iOS || has.OperaMini || has.Windows || has.WebOS;
 
  root.has = has;
 
})();

// use webgl by default
// var type = /(canvas|webgl|svg)/.test(url.type) ? url.type : 'webgl';
var type = url.type;
type = /canvas/.test(type) ? 'canvas' : 
       /svg/.test(type) ? 'svg':
       'webgl';

// console.log(type);

// if the browser does not support webgl
// use svg insteal
if (type === 'webgl' && !has.webgl) {
    alert('Yikes! This browser does not support WebGL.');
    type = 'svg';
}

var two = new Two({
  type: Two.Types[type],
  fullscreen: true
}).appendTo(document.body);
Two.Resolution = 4;

console.log(type);

// var circle = two.makeCircle(-70, 0, 50);
// var rect = two.makeRectangle(70, 0, 100, 100);
// circle.fill = '#FF8000';
// rect.fill = 'rgba(0, 200, 255, 0.75)';

// var group = two.makeGroup(circle, rect);
// group.translation.set(two.width / 2, two.height / 2);
// group.scale = 0;
// group.noStroke();

var backGroup = two.makeGroup(),
    frontGroup = two.makeGroup();


/*************************************************/


var start=new Date();
console.log("start timing");

function TimerPoint(desc){
    var now = new Date();
    console.log(desc + ': ' + (now - start) + ' ms');
    start = now;
}


// function generate(amount) {
// 	var r = Math.random() * radius + radius / 2;
// 	return _.map(_.range(amount), function(i) {
// 	  var pct = i / amount;
// 	  var angle = pct * Math.PI * 2;
// 	  var x = r * Math.cos(angle);
// 	  var y = r * Math.sin(angle);
// 	  var anchor = new Two.Anchor(x, y);
// 	  anchor.origin = new Two.Vector().copy(anchor);
// 	  vertices++;
// 	  return anchor;
// 	});
// }


// var makeStraightCircle = function(ox, oy, r) {
//     return makeStraightEllipse(ox, oy, r, r);
// }

// var makeStraightEllipse = function(ox, oy, width, height) {

//       var amount = Two.Resolution;

//       var points = _.map(_.range(amount), function(i) {
//         var pct = i / amount;
//         var theta = pct * Math.PI*2;
//         var x = width * Math.cos(theta);
//         var y = height * Math.sin(theta);
//         return new Two.Anchor(x, y);
//       }, this);

//       var ellipse = new Two.Polygon(points, true, false);
//       ellipse.translation.set(ox, oy);

//       two.scene.add(ellipse);

//       return ellipse;
// }

/*************************************************/

var offset = 200;
var circleList = [];
for (var i = 0; i < 3000; i++) {
    var circle = two.makeCircle(-offset,-offset,5);
    circle.fill = '#FF8000';
    // circle.noStroke();
    circle.stroke = 'grey';
    circleList.push(circle);
    frontGroup.add(circle);
};
// icoord.map(function(d){
//     var circle = two.makeCircle(scax*(d[0]-minx),scay*(d[1]-miny),5);
//     // var circle = makeStraightCircle(scax*(d[0]-minx),scay*(d[1]-miny),5);
//     // dat.push(scax*(d[0]-minx));
//     circle.fill = '#FF8000';
//     // circleList.push(circle)
// });

TimerPoint('Build Circles');


/*************************************************/

var lineInitialLength = 100;
var lineList = [];
for (var i = 0; i < 10000; i++) {
    var line = two.makeLine(-lineInitialLength*2,0,-lineInitialLength,0);
    backGroup.add(line);
    lineList.push(line)
};

TimerPoint('Build Lines');

/*************************************************/

xcoord = icoord.map(function(d){return d[0]});
ycoord = icoord.map(function(d){return d[1]});
// console.log(xcoord,ycoord);
var maxx = Math.max.apply(null,xcoord),
    minx = Math.min.apply(null,xcoord),
    scax = two.width/(maxx - minx),
    maxy = Math.max.apply(null,ycoord),
    miny = Math.min.apply(null,ycoord),
    scay = two.height/(maxy - miny);

// console.log(two.width);
TimerPoint('Get Scale');



/*************************************************/

for (var i = iedges.length - 1; i >= 0; i--) {
    var d = iedges[i];
    var line = lineList[i];
    var x1 = scax*(icoord[d[0]][0]-minx),
        y1 = scay*(icoord[d[0]][1]-miny),
        x2 = scax*(icoord[d[1]][0]-minx),
        y2 = scay*(icoord[d[1]][1]-miny);
    var lineLength = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
    line.scale = lineLength/lineInitialLength;
    // calculating the rotation is quite subtle here
    // rotation in two is clockwith
    // reg in atan2 is anticlockwith
    line.rotation = -Math.atan2(y1-y2, x2-x1);
    line.translation.x = (x1+x2)/2;
    line.translation.y = (y1+y2)/2;

};
TimerPoint('Move Lines');

/*************************************************/

for (var i = icoord.length - 1; i >= 0; i--) {
    var d = icoord[i];
    circleList[i].translation.set(scax*(d[0]-minx),scay*(d[1]-miny));
};
TimerPoint('Move Circles');

/*************************************************/

two.update();

TimerPoint('Update');


</script>
</body>
</html>